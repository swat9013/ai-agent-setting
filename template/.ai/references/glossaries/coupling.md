# 結合度・コナーセンス リファレンス

## 結合度（Coupling）- 弱い順

| 種類 | 説明 | 問題度 |
|------|------|--------|
| **データ結合** | プリミティブなデータのみを渡す | ✅ 最良 |
| **スタンプ結合** | 複合データ構造を渡すが一部のみ使用 | ⚠️ 軽度 |
| **制御結合** | 制御フラグを渡して振る舞いを変える | ⚠️ 中度 |
| **共通結合** | グローバル変数・状態を共有 | ❌ 高度 |
| **内容結合** | 他モジュールの内部を直接参照・変更 | ❌ 最悪 |

**方向性指標**:
- **求心性結合（Afferent）**: このモジュールに依存する数 → 高いと影響範囲大
- **遠心性結合（Efferent）**: このモジュールが依存する数 → 高いと責務過多

## コナーセンス（Connascence）

「一方を変更したとき、他方も変更が必要」になる依存関係の分類。

### 静的コナーセンス（弱い順）

| 種類 | 説明 | 例 | 改善策 |
|------|------|-----|--------|
| **名前（CoN）** | 同じ名前を参照 | 関数名、変数名 | 意図を明確にした命名 |
| **型（CoT）** | 同じ型を期待 | 引数の型、戻り値の型 | 型定義の共有 |
| **意味（CoM）** | 特定の値に意味を付与 | `status == 1` でアクティブ | 列挙型・定数に抽出 |
| **位置（CoP）** | 順序に依存 | 位置引数、配列のインデックス | 名前付き引数、辞書/オブジェクト |
| **アルゴリズム（CoA）** | 同じアルゴリズムを使用 | ハッシュ、暗号化、バリデーション | 単一の共有実装に集約 |

### 動的コナーセンス（より強い）

| 種類 | 説明 | 例 | 改善策 |
|------|------|-----|--------|
| **実行順序（CoE）** | 呼び出し順序に依存 | init()→process()→cleanup() | 状態機械、ビルダーパターン |
| **タイミング（CoTm）** | 実行タイミングに依存 | 競合状態、タイムアウト | 同期機構、イベント駆動 |
| **値（CoV）** | 複数の値が一緒に変わる | テストと実装の同じ値 | 間接参照（定数、設定） |
| **同一性（CoI）** | 同じインスタンスを参照 | 共有オブジェクト | 明示的な依存注入 |

### 評価の3軸

1. **強度（Strength）**: 強いほどリファクタリング困難
2. **局所性（Locality）**: 遠いほど問題（同一ファイル内なら許容）
3. **程度（Degree）**: 影響範囲が広いほど問題

## コード例

```typescript
// ❌ 位置のコナーセンス（CoP）
function createUser(name: string, email: string, age: number, isAdmin: boolean) {}
createUser("John", "john@example.com", 30, true); // 順序を覚える必要

// ✅ 名前のコナーセンス（CoN）に改善
function createUser(params: { name: string; email: string; age: number; isAdmin: boolean }) {}
createUser({ name: "John", email: "john@example.com", age: 30, isAdmin: true });
```

```typescript
// ❌ 共通結合（グローバル状態）
let currentUser: User | null = null;
function processOrder() {
  if (currentUser) { /* ... */ } // グローバル変数に依存
}

// ✅ データ結合（明示的な引数）
function processOrder(user: User) { /* ... */ }
```
