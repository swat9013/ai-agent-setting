# モデリング用語集

コードレビュー時のモデリング提案で使用する用語の定義。

## 基本原則: 高凝集・疎結合

**関連するデータとロジックは同じ場所にまとめる。**

| 置き場所 | データ | ロジック | 例 |
|----------|--------|----------|-----|
| バリューオブジェクト | 値の属性 | その値に関する操作・検証 | Money.add(), Email.validate() |
| エンティティ | 状態 | 状態を変更する操作 | Order.cancel(), User.changeEmail() |
| ドメインサービス | なし | 上記のどこにも属さない操作 | TransferService.execute() |

ドメインサービスは「どこにも属さない」場合の最後の手段。安易に使うと貧血ドメインモデル（データだけのオブジェクト + ロジックだけのサービス）になる。

---

## リソース vs イベント

| 概念 | 定義 | 特徴 | 例 |
|------|------|------|-----|
| **リソース** | システムの現在状態を表すデータ | CRUDで管理、更新される | User, Order, Product |
| **イベント** | 過去に起きた事実の記録 | 不変、追記のみ、削除しない | OrderPlaced, PaymentReceived |

**判断基準**: 「このデータは更新されるか？」
- Yes → リソース
- No（事実の記録）→ イベント

**update/deleteの注意点**:
リソースへのupdate/deleteは「過去の事実の消失」を意味する。以下の場合はイベントとして記録すべき:
- 監査が必要（誰が・いつ・何を変更したか）
- 履歴参照が必要（過去の状態を知りたい）
- 取り消し・やり直しが必要

**分離の効果**:
- 監査ログ・履歴の完全性
- イベントソーシングへの発展可能性
- リソースのスキーマ変更が履歴に影響しない

---

## エンティティ vs バリューオブジェクト

| 概念 | 定義 | 識別方法 | 例 |
|------|------|----------|-----|
| **エンティティ** | 同一性（ID）で識別されるオブジェクト | IDが同じなら同一 | User(id=1), Order(id=abc) |
| **バリューオブジェクト** | 属性の値で識別されるオブジェクト | 全属性が同じなら同一 | Money(100, JPY), Email("a@b.com") |

**判断基準**: 「同じ属性値を持つ2つのインスタンスは同一とみなせるか？」
- Yes → バリューオブジェクト
- No（別物として扱う必要がある）→ エンティティ

**バリューオブジェクトの特徴**:
- 不変（immutable）: 変更時は新しいインスタンスを生成
- 等値比較: 全属性が一致すれば等しい
- 自己検証: 生成時にバリデーション

**VO化の効果**:
- 型安全性の向上（プリミティブ型の誤用防止）
- バリデーションロジックの集約
- ドメイン知識の明示化

---

## ドメインサービス

| 概念 | 定義 | 例 |
|------|------|-----|
| **ドメインサービス** | VO・エンティティのどちらにも属さないドメインロジック | TransferService.execute(from, to, amount) |

**使い所**:
- 複数の集約をまたぐ操作（送金: 送金元と送金先）
- 外部サービス連携のドメインロジック

**判断の優先順位**:
1. まずVOに置けないか検討
2. 次にエンティティに置けないか検討
3. どちらにも属さない場合のみドメインサービス

---

## 集約（Aggregate）

| 概念 | 定義 |
|------|------|
| **集約** | 整合性を保つ単位。集約ルート経由でのみ内部にアクセス |
| **集約ルート** | 集約の入口となるエンティティ。外部からはこれを通じてアクセス |

**例**: Order（集約ルート）→ OrderLine（内部エンティティ）

**設計指針**:
- 集約は小さく保つ（1トランザクション = 1集約の更新が理想）
- 集約間の参照はIDのみ（オブジェクト参照ではなく）
